import 'package:flutter_test/flutter_test.dart';
import 'package:silni_app/shared/models/relative_model.dart';

import '../../helpers/test_helpers.dart';

// Import enums for type checking
// (Already included in relative_model.dart)

/// Unit tests for RelativesService logic
///
/// NOTE: These tests focus on the business logic that can be tested
/// independently of the Supabase client (data transformation, filtering, sorting).
///
/// LIMITATION: RelativesService uses SupabaseConfig.client (singleton), which
/// makes it difficult to mock database operations without dependency injection.
///
/// For full integration testing of database operations, consider:
/// 1. Refactoring RelativesService to accept SupabaseClient via constructor
/// 2. Using integration tests with a test Supabase instance
/// 3. Using a service locator pattern (e.g., GetIt) for dependency injection

void main() {
  group('RelativesService Logic Tests', () {
    group('Data transformation tests', () {
      test('should correctly transform JSON to Relative model', () {
        // Arrange
        final relativeData = createTestRelativeMap(
          id: 'test-id',
          userId: 'user-123',
          fullName: 'Ahmed Ali',
          relationshipType: 'brother',
        );

        // Act
        final relative = Relative.fromJson(relativeData);

        // Assert
        expect(relative.id, 'test-id');
        expect(relative.userId, 'user-123');
        expect(relative.fullName, 'Ahmed Ali');
        expect(relative.relationshipType, RelationshipType.brother);
        expect(relative.gender, Gender.male);
        expect(relative.priority, 2);
        expect(relative.isArchived, false);
        expect(relative.isFavorite, false);
      });

      test('should correctly transform Relative model to JSON', () {
        // Arrange
        final relativeData = createTestRelativeMap(
          id: 'test-id',
          userId: 'user-123',
          fullName: 'Fatima Hassan',
          relationshipType: 'sister',
        );
        final relative = Relative.fromJson(relativeData);

        // Act
        final json = relative.toJson();

        // Assert
        expect(json, isA<Map<String, dynamic>>());
        // Note: id is not included in toJson() as it's auto-generated by database
        expect(json['user_id'], 'user-123');
        expect(json['full_name'], 'Fatima Hassan');
        expect(json['relationship_type'], 'sister'); // enum.value returns string
        // Note: created_at and updated_at are not included in toJson()
        expect(json.containsKey('date_of_birth'), true);
        expect(json.containsKey('phone_number'), true);
      });

      test('should handle null optional fields correctly', () {
        // Arrange
        final relativeData = createTestRelativeMap();

        // Act
        final relative = Relative.fromJson(relativeData);
        final json = relative.toJson();

        // Assert
        expect(relative.dateOfBirth, isNull);
        expect(relative.address, isNull);
        expect(relative.city, isNull);
        expect(relative.country, isNull);
        expect(relative.photoUrl, isNull);
        expect(relative.notes, isNull);
        expect(json['date_of_birth'], isNull);
        expect(json['address'], isNull);
      });

      test('should preserve all required fields in round-trip conversion', () {
        // Arrange
        final originalData = createTestRelativeMap(
          id: 'round-trip-test',
          userId: 'user-456',
          fullName: 'Test User',
          relationshipType: 'cousin',
        );

        // Act - Convert JSON -> Model -> JSON
        final relative = Relative.fromJson(originalData);
        final convertedData = relative.toJson();

        // Assert - All fields that toJson() includes are preserved
        // Note: id, created_at, updated_at are not in toJson()
        expect(convertedData['user_id'], originalData['user_id']);
        expect(convertedData['full_name'], originalData['full_name']);
        expect(convertedData['relationship_type'],
            originalData['relationship_type']);
        expect(convertedData['gender'], originalData['gender']);
        expect(convertedData['priority'], originalData['priority']);
        expect(convertedData['is_archived'], originalData['is_archived']);
        expect(convertedData['is_favorite'], originalData['is_favorite']);
      });

      test('should handle different relationship types correctly', () {
        // Arrange & Act
        final brother =
            Relative.fromJson(createTestRelativeMap(relationshipType: 'brother'));
        final sister =
            Relative.fromJson(createTestRelativeMap(relationshipType: 'sister'));
        final father =
            Relative.fromJson(createTestRelativeMap(relationshipType: 'father'));
        final mother =
            Relative.fromJson(createTestRelativeMap(relationshipType: 'mother'));

        // Assert
        expect(brother.relationshipType, RelationshipType.brother);
        expect(sister.relationshipType, RelationshipType.sister);
        expect(father.relationshipType, RelationshipType.father);
        expect(mother.relationshipType, RelationshipType.mother);
      });
    });

    group('Client-side filtering logic tests', () {
      test('should filter relatives by user ID', () {
        // Arrange
        final allRelatives = [
          createTestRelativeMap(id: '1', userId: 'user-1'),
          createTestRelativeMap(id: '2', userId: 'user-2'),
          createTestRelativeMap(id: '3', userId: 'user-1'),
          createTestRelativeMap(id: '4', userId: 'user-3'),
        ];

        // Act - Simulate the filtering logic from getRelativesStream
        final filtered = allRelatives
            .where((json) => json['user_id'] == 'user-1')
            .map((json) => Relative.fromJson(json))
            .toList();

        // Assert
        expect(filtered.length, 2);
        expect(filtered.every((r) => r.userId == 'user-1'), true);
      });

      test('should exclude archived relatives', () {
        // Arrange
        final allRelatives = [
          createTestRelativeMap(id: '1')..['is_archived'] = false,
          createTestRelativeMap(id: '2')..['is_archived'] = true,
          createTestRelativeMap(id: '3')..['is_archived'] = false,
          createTestRelativeMap(id: '4')..['is_archived'] = true,
        ];

        // Act - Simulate the filtering logic from getRelativesStream
        final filtered = allRelatives
            .where((json) => json['is_archived'] == false)
            .map((json) => Relative.fromJson(json))
            .toList();

        // Assert
        expect(filtered.length, 2);
        expect(filtered.every((r) => !r.isArchived), true);
      });

      test('should filter by user ID AND exclude archived', () {
        // Arrange
        final allRelatives = [
          createTestRelativeMap(id: '1', userId: 'user-1')..['is_archived'] = false,
          createTestRelativeMap(id: '2', userId: 'user-1')..['is_archived'] = true,
          createTestRelativeMap(id: '3', userId: 'user-2')..['is_archived'] = false,
          createTestRelativeMap(id: '4', userId: 'user-1')..['is_archived'] = false,
        ];

        // Act - Simulate the combined filtering from getRelativesStream
        final filtered = allRelatives
            .where((json) =>
                json['user_id'] == 'user-1' && json['is_archived'] == false)
            .map((json) => Relative.fromJson(json))
            .toList();

        // Assert
        expect(filtered.length, 2);
        expect(filtered.every((r) => r.userId == 'user-1' && !r.isArchived),
            true);
      });

      test('should filter favorite relatives', () {
        // Arrange
        final allRelatives = [
          createTestRelativeMap(id: '1', userId: 'user-1')
            ..['is_favorite'] = true
            ..['is_archived'] = false,
          createTestRelativeMap(id: '2', userId: 'user-1')
            ..['is_favorite'] = false
            ..['is_archived'] = false,
          createTestRelativeMap(id: '3', userId: 'user-1')
            ..['is_favorite'] = true
            ..['is_archived'] = false,
        ];

        // Act - Simulate getFavoriteRelatives filtering
        final filtered = allRelatives
            .where((json) =>
                json['user_id'] == 'user-1' &&
                json['is_favorite'] == true &&
                json['is_archived'] == false)
            .map((json) => Relative.fromJson(json))
            .toList();

        // Assert
        expect(filtered.length, 2);
        expect(filtered.every((r) => r.isFavorite), true);
      });

      test('should search relatives by name (case-insensitive)', () {
        // Arrange
        final relatives = [
          Relative.fromJson(createTestRelativeMap(fullName: 'Ahmed Ali')),
          Relative.fromJson(createTestRelativeMap(fullName: 'Fatima Hassan')),
          Relative.fromJson(createTestRelativeMap(fullName: 'Ali Ahmed')),
          Relative.fromJson(createTestRelativeMap(fullName: 'Mohammed Said')),
        ];
        const query = 'ali';

        // Act - Simulate searchRelatives logic
        final searchResults = relatives
            .where((r) => r.fullName.toLowerCase().contains(query.toLowerCase()))
            .toList();

        // Assert
        expect(searchResults.length, 2);
        expect(searchResults[0].fullName, 'Ahmed Ali');
        expect(searchResults[1].fullName, 'Ali Ahmed');
      });

      test('should return all relatives when search query is empty', () {
        // Arrange
        final relatives = [
          Relative.fromJson(createTestRelativeMap(fullName: 'Ahmed')),
          Relative.fromJson(createTestRelativeMap(fullName: 'Fatima')),
          Relative.fromJson(createTestRelativeMap(fullName: 'Ali')),
        ];
        const query = '';

        // Act - Simulate searchRelatives logic
        final searchResults = query.isEmpty
            ? relatives
            : relatives
                .where((r) =>
                    r.fullName.toLowerCase().contains(query.toLowerCase()))
                .toList();

        // Assert
        expect(searchResults.length, 3);
      });

      test('should handle search with special characters', () {
        // Arrange
        final relatives = [
          Relative.fromJson(createTestRelativeMap(fullName: 'أحمد علي')),
          Relative.fromJson(createTestRelativeMap(fullName: 'فاطمة حسن')),
          Relative.fromJson(createTestRelativeMap(fullName: 'علي أحمد')),
        ];
        const query = 'أحمد';

        // Act
        final searchResults = relatives
            .where((r) => r.fullName.toLowerCase().contains(query.toLowerCase()))
            .toList();

        // Assert
        expect(searchResults.length, 2);
      });
    });

    group('Sorting logic tests', () {
      test('should sort relatives by priority ascending', () {
        // Arrange
        final relatives = [
          Relative.fromJson(createTestRelativeMap(fullName: 'C')..['priority'] = 3),
          Relative.fromJson(createTestRelativeMap(fullName: 'A')..['priority'] = 1),
          Relative.fromJson(createTestRelativeMap(fullName: 'B')..['priority'] = 2),
        ];

        // Act - Simulate sorting logic from getRelativesStream
        relatives.sort((a, b) => a.priority.compareTo(b.priority));

        // Assert
        expect(relatives[0].priority, 1);
        expect(relatives[1].priority, 2);
        expect(relatives[2].priority, 3);
        expect(relatives[0].fullName, 'A');
        expect(relatives[1].fullName, 'B');
        expect(relatives[2].fullName, 'C');
      });

      test('should sort by name when priority is the same', () {
        // Arrange
        final relatives = [
          Relative.fromJson(
              createTestRelativeMap(fullName: 'Charlie')..['priority'] = 2),
          Relative.fromJson(
              createTestRelativeMap(fullName: 'Alice')..['priority'] = 2),
          Relative.fromJson(
              createTestRelativeMap(fullName: 'Bob')..['priority'] = 2),
        ];

        // Act - Simulate sorting logic from getRelativesStream
        relatives.sort((a, b) {
          final priorityCompare = a.priority.compareTo(b.priority);
          if (priorityCompare != 0) return priorityCompare;
          return a.fullName.compareTo(b.fullName);
        });

        // Assert
        expect(relatives[0].fullName, 'Alice');
        expect(relatives[1].fullName, 'Bob');
        expect(relatives[2].fullName, 'Charlie');
        // All should have same priority
        expect(relatives.every((r) => r.priority == 2), true);
      });

      test('should sort by priority first, then by name', () {
        // Arrange
        final relatives = [
          Relative.fromJson(
              createTestRelativeMap(fullName: 'Bob')..['priority'] = 1),
          Relative.fromJson(
              createTestRelativeMap(fullName: 'Alice')..['priority'] = 2),
          Relative.fromJson(
              createTestRelativeMap(fullName: 'Charlie')..['priority'] = 1),
          Relative.fromJson(
              createTestRelativeMap(fullName: 'David')..['priority'] = 2),
        ];

        // Act - Simulate sorting logic from getRelativesStream
        relatives.sort((a, b) {
          final priorityCompare = a.priority.compareTo(b.priority);
          if (priorityCompare != 0) return priorityCompare;
          return a.fullName.compareTo(b.fullName);
        });

        // Assert
        expect(relatives[0].fullName, 'Bob'); // priority 1
        expect(relatives[1].fullName, 'Charlie'); // priority 1
        expect(relatives[2].fullName, 'Alice'); // priority 2
        expect(relatives[3].fullName, 'David'); // priority 2
      });

      test('should handle empty list gracefully', () {
        // Arrange
        final relatives = <Relative>[];

        // Act
        relatives.sort((a, b) {
          final priorityCompare = a.priority.compareTo(b.priority);
          if (priorityCompare != 0) return priorityCompare;
          return a.fullName.compareTo(b.fullName);
        });

        // Assert
        expect(relatives, isEmpty);
      });

      test('should handle single item list', () {
        // Arrange
        final relatives = [
          Relative.fromJson(createTestRelativeMap(fullName: 'Solo')
            ..['priority'] = 5),
        ];

        // Act
        relatives.sort((a, b) {
          final priorityCompare = a.priority.compareTo(b.priority);
          if (priorityCompare != 0) return priorityCompare;
          return a.fullName.compareTo(b.fullName);
        });

        // Assert
        expect(relatives.length, 1);
        expect(relatives[0].fullName, 'Solo');
      });
    });

    group('Combined operations tests', () {
      test('should filter, then search, then sort relatives correctly', () {
        // Arrange
        final allRelatives = [
          createTestRelativeMap(
            id: '1',
            userId: 'user-1',
            fullName: 'Ahmed Ali',
          )
            ..['priority'] = 2
            ..['is_archived'] = false,
          createTestRelativeMap(
            id: '2',
            userId: 'user-1',
            fullName: 'Ali Ahmed',
          )
            ..['priority'] = 1
            ..['is_archived'] = false,
          createTestRelativeMap(
            id: '3',
            userId: 'user-2',
            fullName: 'Ali Hassan',
          )
            ..['priority'] = 3
            ..['is_archived'] = false,
          createTestRelativeMap(
            id: '4',
            userId: 'user-1',
            fullName: 'Mohammed Ali',
          )
            ..['priority'] = 1
            ..['is_archived'] = true,
        ];
        const userId = 'user-1';
        const searchQuery = 'ali';

        // Act - Simulate the full pipeline
        // 1. Filter by user and non-archived
        var filtered = allRelatives
            .where((json) =>
                json['user_id'] == userId && json['is_archived'] == false)
            .map((json) => Relative.fromJson(json))
            .toList();

        // 2. Search by name
        if (searchQuery.isNotEmpty) {
          filtered = filtered
              .where((r) =>
                  r.fullName.toLowerCase().contains(searchQuery.toLowerCase()))
              .toList();
        }

        // 3. Sort by priority then name
        filtered.sort((a, b) {
          final priorityCompare = a.priority.compareTo(b.priority);
          if (priorityCompare != 0) return priorityCompare;
          return a.fullName.compareTo(b.fullName);
        });

        // Assert
        expect(filtered.length, 2); // Only user-1, non-archived, with "ali"
        expect(filtered[0].fullName, 'Ali Ahmed'); // priority 1
        expect(filtered[1].fullName, 'Ahmed Ali'); // priority 2
      });

      test('should correctly identify relatives needing contact', () {
        // Arrange - Create relatives with different last contact dates
        final now = DateTime.now();
        final relatives = [
          Relative.fromJson(createTestRelativeMap()
            ..['priority'] = 1
            ..['last_contact_date'] =
                now.subtract(const Duration(days: 8)).toIso8601String()),
          Relative.fromJson(createTestRelativeMap()
            ..['priority'] = 2
            ..['last_contact_date'] =
                now.subtract(const Duration(days: 15)).toIso8601String()),
          Relative.fromJson(createTestRelativeMap()
            ..['priority'] = 3
            ..['last_contact_date'] =
                now.subtract(const Duration(days: 5)).toIso8601String()),
        ];

        // Act - Filter relatives that need contact (using needsContact getter)
        final needingContact =
            relatives.where((r) => r.needsContact).toList();

        // Assert - Verify the logic works as expected
        expect(needingContact, isNotEmpty);
      });
    });
  });
}
