import 'package:flutter/material.dart';

import '../services/design_config_service.dart';
import 'app_themes.dart';

/// Unified theme model that wraps both admin-configured themes and hardcoded fallbacks.
///
/// This provides a single interface for the UI to work with themes regardless
/// of whether they come from Supabase (admin_themes) or hardcoded defaults.
class DynamicTheme {
  /// Unique key for this theme (e.g., 'default', 'lavender', 'royal')
  final String key;

  /// Arabic display name
  final String displayNameAr;

  /// English display name (optional)
  final String? displayNameEn;

  /// Whether this theme requires premium subscription
  final bool isPremium;

  /// Whether this is the default theme
  final bool isDefault;

  /// The actual theme colors
  final ThemeColors colors;

  /// Optional preview image URL (for admin-configured themes)
  final String? previewImageUrl;

  /// Sort order for display
  final int sortOrder;

  /// Whether this theme came from admin config (vs hardcoded)
  final bool isFromAdmin;

  const DynamicTheme({
    required this.key,
    required this.displayNameAr,
    this.displayNameEn,
    required this.isPremium,
    required this.isDefault,
    required this.colors,
    this.previewImageUrl,
    this.sortOrder = 0,
    this.isFromAdmin = false,
  });

  /// Create a DynamicTheme from an AdminTheme (Supabase)
  factory DynamicTheme.fromAdminTheme(AdminTheme admin) {
    return DynamicTheme(
      key: admin.themeKey,
      displayNameAr: admin.displayNameAr,
      displayNameEn: admin.displayNameEn,
      isPremium: admin.isPremium,
      isDefault: admin.isDefault,
      colors: _themeColorsFromAdmin(admin),
      previewImageUrl: admin.previewImageUrl,
      sortOrder: admin.sortOrder,
      isFromAdmin: true,
    );
  }

  /// Create a DynamicTheme from a hardcoded AppThemeType (fallback)
  factory DynamicTheme.fromAppTheme(AppThemeType type) {
    return DynamicTheme(
      key: type.value,
      displayNameAr: type.arabicName,
      displayNameEn: type.englishName,
      // Default theme is free, others require premium
      isPremium: type != AppThemeType.defaultGreen,
      isDefault: type == AppThemeType.defaultGreen,
      colors: ThemeColors.getTheme(type),
      sortOrder: type.index,
      isFromAdmin: false,
    );
  }

  /// Convert AdminTheme colors JSON to ThemeColors
  static ThemeColors _themeColorsFromAdmin(AdminTheme admin) {
    // Get hardcoded fallback based on theme key (used only for missing colors)
    final fallback = _getFallbackTheme(admin.themeKey);

    // Helper to parse color from JSON
    // Supports both 6-char RGB (#RRGGBB) and 8-char RGBA (#RRGGBBAA)
    Color parseColor(String key, Color fallbackColor) {
      final colorData = admin.colors[key];
      if (colorData == null) return fallbackColor;
      if (colorData is String) {
        try {
          final hex = colorData.replaceFirst('#', '').toUpperCase();
          if (hex.length == 6) {
            // RGB without alpha - add FF for full opacity
            return Color(int.parse('FF$hex', radix: 16));
          } else if (hex.length == 8) {
            // RGBA format (CSS): RRGGBBAA -> Flutter format: AARRGGBB
            final alpha = hex.substring(6, 8);
            final rgb = hex.substring(0, 6);
            return Color(int.parse('$alpha$rgb', radix: 16));
          }
          return fallbackColor;
        } catch (_) {
          return fallbackColor;
        }
      }
      return fallbackColor;
    }

    // Parse all flat colors first (needed for auto-generating gradients)
    final primary = parseColor('primary', fallback.primary);
    final primaryLight = parseColor('primary_light', fallback.primaryLight);
    final primaryDark = parseColor('primary_dark', fallback.primaryDark);
    final secondary = parseColor('secondary', fallback.secondary);
    final accent = parseColor('accent', fallback.accent);
    final background1 = parseColor('background_1', fallback.background1);
    final background2 = parseColor('background_2', fallback.background2);
    final background3 = parseColor('background_3', fallback.background3);

    // Helper to parse gradient from JSON with auto-generation fallback
    LinearGradient parseGradient(
      String key,
      List<Color> autoGeneratedColors,
      LinearGradient hardcodedFallback,
    ) {
      final gradientData = admin.gradients[key];
      if (gradientData != null && gradientData is Map<String, dynamic>) {
        try {
          final colorsList = gradientData['colors'] as List<dynamic>?;
          if (colorsList != null && colorsList.isNotEmpty) {
            final colors = colorsList.map((c) {
              if (c is String) {
                final hex = c.replaceFirst('#', '').toUpperCase();
                if (hex.length == 6) {
                  return Color(int.parse('FF$hex', radix: 16));
                } else if (hex.length == 8) {
                  // RGBA format (CSS): RRGGBBAA -> Flutter format: AARRGGBB
                  final alpha = hex.substring(6, 8);
                  final rgb = hex.substring(0, 6);
                  return Color(int.parse('$alpha$rgb', radix: 16));
                }
              }
              return Colors.grey;
            }).toList();

            return LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: colors,
            );
          }
        } catch (_) {
          // Fall through to auto-generation
        }
      }

      // Auto-generate gradient from parsed flat colors (not hardcoded fallback!)
      if (autoGeneratedColors.isNotEmpty) {
        return LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: autoGeneratedColors,
        );
      }

      return hardcodedFallback;
    }

    return ThemeColors(
      primary: primary,
      primaryLight: primaryLight,
      primaryDark: primaryDark,
      secondary: secondary,
      accent: accent,
      background1: background1,
      background2: background2,
      background3: background3,
      // Auto-generate gradients from parsed colors if not explicitly defined
      primaryGradient: parseGradient(
        'primary',
        [primaryDark, primary, primaryLight],
        fallback.primaryGradient,
      ),
      backgroundGradient: parseGradient(
        'background',
        [background1, background2, background3],
        fallback.backgroundGradient,
      ),
      goldenGradient: parseGradient(
        'golden',
        [accent, secondary],
        fallback.goldenGradient,
      ),
      streakFire: parseGradient(
        'streak_fire',
        [primaryDark, primary, accent],
        fallback.streakFire,
      ),
      healthyGradient: parseGradient(
        'healthy',
        [],
        fallback.healthyGradient,
      ),
      warningGradient: parseGradient(
        'warning',
        [],
        fallback.warningGradient,
      ),
      dangerGradient: parseGradient(
        'danger',
        [],
        fallback.dangerGradient,
      ),
      onPrimary: parseColor('on_primary', fallback.onPrimary),
      onSecondary: parseColor('on_secondary', fallback.onSecondary),
      surface: parseColor('surface', fallback.surface),
      onSurface: parseColor('on_surface', fallback.onSurface),
      surfaceVariant: parseColor('surface_variant', fallback.surfaceVariant),
      onSurfaceVariant: parseColor('on_surface_variant', fallback.onSurfaceVariant),
      glassBackground: parseColor('glass_background', fallback.glassBackground),
      glassBorder: parseColor('glass_border', fallback.glassBorder),
      glassHighlight: parseColor('glass_highlight', fallback.glassHighlight),
      textPrimary: parseColor('text_primary', fallback.textPrimary),
      textSecondary: parseColor('text_secondary', fallback.textSecondary),
      textHint: parseColor('text_hint', fallback.textHint),
      textOnGradient: parseColor('text_on_gradient', fallback.textOnGradient),
      shimmerBase: parseColor('shimmer_base', fallback.shimmerBase),
      shimmerHighlight: parseColor('shimmer_highlight', fallback.shimmerHighlight),
      cardBackground: parseColor('card_background', fallback.cardBackground),
      cardBorder: parseColor('card_border', fallback.cardBorder),
      divider: parseColor('divider', fallback.divider),
      disabled: parseColor('disabled', fallback.disabled),
      // Semantic status colors
      statusSuccess: parseColor('status_success', fallback.statusSuccess),
      statusError: parseColor('status_error', fallback.statusError),
      statusWarning: parseColor('status_warning', fallback.statusWarning),
      statusInfo: parseColor('status_info', fallback.statusInfo),
      // Communication status colors (contact frequency)
      contactExcellent: parseColor('contact_excellent', fallback.contactExcellent),
      contactGood: parseColor('contact_good', fallback.contactGood),
      contactNormal: parseColor('contact_normal', fallback.contactNormal),
      contactNeedsCare: parseColor('contact_needs_care', fallback.contactNeedsCare),
      contactCritical: parseColor('contact_critical', fallback.contactCritical),
      contactElderly: parseColor('contact_elderly', fallback.contactElderly),
      contactDisabled: parseColor('contact_disabled', fallback.contactDisabled),
      // Mood colors
      moodHappy: parseColor('mood_happy', fallback.moodHappy),
      moodNeutral: parseColor('mood_neutral', fallback.moodNeutral),
      moodSad: parseColor('mood_sad', fallback.moodSad),
      moodExcited: parseColor('mood_excited', fallback.moodExcited),
      moodCalm: parseColor('mood_calm', fallback.moodCalm),
      moodWorried: parseColor('mood_worried', fallback.moodWorried),
      // Priority colors
      priorityHigh: parseColor('priority_high', fallback.priorityHigh),
      priorityMedium: parseColor('priority_medium', fallback.priorityMedium),
      priorityLow: parseColor('priority_low', fallback.priorityLow),
      // Level colors
      level1: parseColor('level_1', fallback.level1),
      level2: parseColor('level_2', fallback.level2),
      level3: parseColor('level_3', fallback.level3),
      level4: parseColor('level_4', fallback.level4),
      level5: parseColor('level_5', fallback.level5),
      levelMax: parseColor('level_max', fallback.levelMax),
      // Tier gradients
      tierLegendaryGradient: parseGradient(
        'tier_legendary',
        [],
        fallback.tierLegendaryGradient,
      ),
      tierEpicGradient: parseGradient(
        'tier_epic',
        [],
        fallback.tierEpicGradient,
      ),
      tierRareGradient: parseGradient(
        'tier_rare',
        [],
        fallback.tierRareGradient,
      ),
      tierStarterGradient: parseGradient(
        'tier_starter',
        [],
        fallback.tierStarterGradient,
      ),
    );
  }

  /// Get hardcoded fallback theme by key
  static ThemeColors _getFallbackTheme(String themeKey) {
    switch (themeKey) {
      case 'default':
      case 'defaultGreen':
        return ThemeColors.defaultGreen;
      case 'lavender':
      case 'lavenderPurple':
        return ThemeColors.lavenderPurple;
      case 'royal':
      case 'royalBlue':
        return ThemeColors.royalBlue;
      case 'sunset':
      case 'sunsetOrange':
        return ThemeColors.sunsetOrange;
      case 'rose':
      case 'roseGold':
        return ThemeColors.roseGold;
      case 'midnight':
      case 'midnightDark':
        return ThemeColors.midnightDark;
      default:
        return ThemeColors.defaultGreen;
    }
  }

  /// Get all available themes - admin first, then hardcoded fallbacks
  static List<DynamicTheme> getAllThemes() {
    final service = DesignConfigService.instance;

    // If admin themes are loaded and available, use them
    if (service.isLoaded && service.themes.isNotEmpty) {
      return service.themes
          .map((t) => DynamicTheme.fromAdminTheme(t))
          .toList();
    }

    // Fallback to hardcoded themes
    return AppThemeType.values
        .map((t) => DynamicTheme.fromAppTheme(t))
        .toList();
  }

  /// Find a theme by key
  static DynamicTheme? findByKey(String key) {
    final themes = getAllThemes();
    try {
      return themes.firstWhere((t) => t.key == key);
    } catch (_) {
      return null;
    }
  }

  /// Get the default theme
  static DynamicTheme getDefault() {
    final themes = getAllThemes();
    try {
      return themes.firstWhere((t) => t.isDefault);
    } catch (_) {
      return themes.isNotEmpty
          ? themes.first
          : DynamicTheme.fromAppTheme(AppThemeType.defaultGreen);
    }
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DynamicTheme &&
          runtimeType == other.runtimeType &&
          key == other.key;

  @override
  int get hashCode => key.hashCode;
}
